/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package hu.bzolt.webdsl.entity

import com.google.inject.Inject
import hu.bzolt.webdsl.jvmmodel.AnnotationRefHelper
import hu.bzolt.webdsl.jvmmodel.InferrerHelper
import hu.bzolt.webdsl.webDsl.Attribute
import hu.bzolt.webdsl.webDsl.Bool
import hu.bzolt.webdsl.webDsl.Date
import hu.bzolt.webdsl.webDsl.Entity
import hu.bzolt.webdsl.webDsl.EntityRef
import hu.bzolt.webdsl.webDsl.Num
import hu.bzolt.webdsl.webDsl.Text
import hu.bzolt.webdsl.webDsl.Type
import java.util.ArrayList
import java.util.List
import org.eclipse.xtext.common.types.JvmAnnotationReference
import org.eclipse.xtext.common.types.JvmMember
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmAnnotationReferenceBuilder
import org.eclipse.xtext.xbase.jvmmodel.JvmTypeReferenceBuilder
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class EntityInferrer // extends AbstractModelInferrer
{
	extension JvmAnnotationReferenceBuilder _annotationTypesBuilder;
	extension JvmTypeReferenceBuilder _typeReferenceBuilder;

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject
	extension JvmTypesBuilder

	@Inject
	extension AnnotationRefHelper

	@Inject
	extension InferrerHelper

	def ArrayList<JvmMember> processAttributes(Entity e, String prefix)
	{
		val members = new ArrayList<JvmMember>
		var entities = new ArrayList<String>
		entities.add(e.name)
		if (!infiniteFlatLoop(e, entities))
		{
			for (a : e.attributes)
			{
				val memberName = a.memberName(prefix)
				if (a.type instanceof EntityRef && (a.type as EntityRef).flat)
				{
					members += (a.type as EntityRef).entity.processAttributes(memberName)
				}
				else
				{
					members += a.process(memberName)
				}
			}
		}
		return members
	}

	def process(Attribute a, String memberName)
	{
		val members = new ArrayList<JvmMember>
		val typeName = if (a.list) a.listTypeName else a.typeName
		members += a.toField(memberName, typeName, [
			if (a.required)
			{
				annotations += annotationRef(NotNull)
			}
			if (a.list && a.type instanceof EntityRef)
			{
				annotations += annotationRef(Valid)
			}
			else
			{
				annotations += a.type.toAnnotations
			}

		])
		members += a.toGetter(memberName, typeName)
		members += a.toSetter(memberName, typeName)
		if (a.list)
		{
			members += a.toMethod("add" + memberName.toFirstUpper, typeRef(void)) [
				parameters += a.toParameter("item", a.typeName)
				body = '''this.«memberName».add(item);'''
			]
		}
		return members
	}

	def memberName(Attribute a, String prefix)
	{
		if (prefix === null || prefix.empty)
		{
			return a.name
		}
		else
		{
			return prefix + a.name.toFirstUpper
		}
	}

	def listTypeName(Attribute a)
	{
		return typeRef(List, a.typeName)
	}

	def typeName(Attribute a)
	{
		return switch (a.type)
		{
			Text: typeRef(String)
			Num: typeRef(int)
			Bool: typeRef(boolean)
			Date: typeRef(java.util.Date)
			EntityRef: typeRef((a.type as EntityRef).entity.className)
		}
	}

	def dispatch toAnnotations(Num n)
	{
		val annotations = new ArrayList<JvmAnnotationReference>

		if (n.min > 0)
		{
			annotations += annotationRef(Min).intValues(new Pair(null, n.min))
		}
		if (n.max > 0)
		{
			annotations += annotationRef(Max).intValues(new Pair(null, n.max))
		}

		return annotations
	}

	def dispatch toAnnotations(Text t)
	{
		val annotations = new ArrayList<JvmAnnotationReference>

		val sizePairs = new ArrayList<Pair<String, Integer>>
		if (t.minLength > 0)
		{
			sizePairs += new Pair("min", t.minLength)
		}
		if (t.maxLength > 0)
		{
			sizePairs += new Pair("max", t.maxLength)
		}
		if (!sizePairs.empty)
		{
			annotations += annotationRef(Size).intValues(sizePairs)
		}
		return annotations
	}

	def dispatch toAnnotations(Date d)
	{
		val annotations = new ArrayList<JvmAnnotationReference>

		if (d.past)
		{
			annotations += annotationRef(Past)
		}
		else if (d.future)
		{
			annotations += annotationRef(Future)
		}

		return annotations
	}

	def dispatch toAnnotations(Type t)
	{
	}

	def infer(Entity e, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase,
		JvmAnnotationReferenceBuilder annotationTypesBuilder,
		JvmTypeReferenceBuilder typeReferenceBuilder)
		{
			this._annotationTypesBuilder = annotationTypesBuilder;
			this._typeReferenceBuilder = typeReferenceBuilder;
			val entityClass = e.toClass(e.className)
			acceptor.accept(entityClass) [
				members += e.toConstructor[]
				members += e.processAttributes("")
			]
		}
	}
	